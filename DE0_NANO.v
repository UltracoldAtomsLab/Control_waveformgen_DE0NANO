
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module DE0_NANO(

	//////////// CLOCK //////////
	input 		          		CLOCK_50,

	//////////// LED //////////
	output		     [7:0]		LED,

	//////////// KEY //////////
	input 		     [1:0]		KEY,

	//////////// SW //////////
	input 		     [3:0]		SW,

	//////////// SDRAM //////////
	output		    [12:0]		DRAM_ADDR,
	output		     [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [15:0]		DRAM_DQ,
	output		     [1:0]		DRAM_DQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_WE_N,

	//////////// EPCS //////////
	output		          		EPCS_ASDO,
	input 		          		EPCS_DATA0,
	output		          		EPCS_DCLK,
	output		          		EPCS_NCSO,

	//////////// Accelerometer and EEPROM //////////
	output		          		G_SENSOR_CS_N,
	input 		          		G_SENSOR_INT,
	output		          		I2C_SCLK,
	inout 		          		I2C_SDAT,

	//////////// ADC //////////
	output		          		ADC_CS_N,
	output		          		ADC_SADDR,
	output		          		ADC_SCLK,
	input 		          		ADC_SDAT,

	//////////// 2x13 GPIO Header //////////
	inout 		    [12:0]		GPIO_2,
	input 		     [2:0]		GPIO_2_IN,

	//////////// GPIO_0, GPIO_0 connect to GPIO Default //////////
	output 		    [33:0]		GPIO_0,
	input 		     [1:0]		GPIO_0_IN,

	//////////// GPIO_1, GPIO_1 connect to GPIO Default //////////
	inout 		    [33:0]		GPIO_1,
	input 		     [1:0]		GPIO_1_IN
);



//=======================================================
//  REG/WIRE declarations
//=======================================================

`include "v/para.h"

wire               nRst;
reg  [7:0]         reset_count;
wire               m_cmd_reset;
reg                cmd_reset;
wire               Armed;
wire [7:0]         mMode;
wire               mFlagTimeReady;
wire               mFlagChValueReady;
wire [7:0]         mDataChannel;
wire [`bitNum-1:0] mDataTime;
wire               mDataChValue;
reg  [7:0]         Mode;
reg                FlagTimeReady;
reg                FlagChValueReady;
reg  [7:0]         DataChannel;
reg  [`bitNum-1:0] DataTime;
reg                DataChValue;
wire               TriggerLinein;
wire               TriggerOut;
wire [254:0]       Waveform;
reg                CLK_custom;
reg  [11:0]        clk_cnt, clk_cnt_max;
wire               CLK_custom_reset;
wire [7:0]         Test;
wire							 mFlagSplRateReady;
wire [7:0]				 mSplRate;
reg	[3:0]			LED_buffer;

assign GPIO_0[31:24] = Test;
assign LED[7] = Armed;
/*writen for debuging
always @(posedge CLOCK_50)begin
	LED_buffer[3:0] <= Waveform[3:0]; 
end
assign LED[3:0] = LED_buffer[3:0];
*/
assign GPIO_0[7:0] = Waveform[7:0];
assign GPIO_0[15:8] = Waveform[15:8];
assign GPIO_0[22:16] = Waveform[22:16];
assign GPIO_0[23] = CLK_custom;

assign GPIO_1[0]  = TriggerOut;
assign TriggerLinein = GPIO_1[1];
assign GPIO_1[2] = TriggerLinein;
assign nRst = (reset_count==0);



//=======================================================
//  Structural coding
//=======================================================

always @ (posedge CLOCK_50) begin
	if(reset_count != 7'h00)
		reset_count <= reset_count + 1'b1;
	else
		reset_count <= reset_count + cmd_reset;


	if(CLK_custom_reset) begin
		clk_cnt <= 12'd0;
		CLK_custom <= 1'b0;
	end
	else if(clk_cnt >= clk_cnt_max) begin
		clk_cnt <= 12'd0;
		CLK_custom <= ~CLK_custom;
	end
	else
		clk_cnt <= clk_cnt + 1'b1;
end

always @ (posedge mFlagSplRateReady)
begin
	clk_cnt_max <= (mSplRate*10-1'b1);
end



always @ (posedge CLOCK_50 or negedge nRst) begin
	if (!nRst)begin
		Mode          <= 8'h00;
		FlagTimeReady <= 1'b0;
		FlagChValueReady <= 1'b0;
		DataChannel   <= 8'h00;
		DataTime      <= `bitNum'h00000000;
		DataChValue   <= 1'b0;
		cmd_reset     <= 1'b0;
	end
	else begin
		cmd_reset        <= m_cmd_reset;
		Mode             <= mMode;
		FlagTimeReady    <= mFlagTimeReady;
		FlagChValueReady <= mFlagChValueReady;
		DataChannel      <= mDataChannel;
		DataTime         <= mDataTime;
		DataChValue      <= mDataChValue;
	end
end
RS232_CONTROL rs232_0(
	.iNRST(nRst),               // the reset signal
	.iCLK (CLOCK_50),             // the clock, 50M Hz
	.iRXD (GPIO_1_IN[0]),            // recieving channel from computer

	.oMode                  (mMode),
	.oMODE_SET_CH_WAVEFORM  (),
	.oMODE_SET_CH_INIT_VAL  (),
	.oMODE_SET_CH_VAL_FORCED(),
	.oMODE_SET_PERIOD       (),
	.oMODE_CMD_ARM          (),
	.oMODE_CMD_TO_INIT      (),
	.oMODE_CMD_RESET_TIME   (),
	.oMODE_CMD_RESET_DEV    (m_cmd_reset),

	.oFLAG_TIME_READY       (mFlagTimeReady),
	.oFLAG_CH_VAL_READY     (mFlagChValueReady),
	.oFLAG_SPL_RATE_READY		(mFlagSplRateReady),
	.oDATA_CHANNEL          (mDataChannel),
	.oDATA_TIME             (mDataTime),
	.oDATA_CH_VAL           (mDataChValue),
	.oSPL_RATE							(mSplRate),
);


SEQ_WAVE_GEN seq_wave_gen0(
	.iNRST    (nRst),
	.iCLK     (CLOCK_50), // 12.5M
	.iTRIG    (TriggerLinein),
	.iCTRL_MODE        (Mode),
	.iFLAG_TIME_READY  (FlagTimeReady),
	.iFLAG_CH_VAL_READY(FlagChValueReady),
	.iDATA_CHANNEL     (DataChannel),
	.iDATA_TIME        (DataTime),
	.iDATA_CH_VAL      (DataChValue),

	.oWAVEFORM (Waveform),
	.oTRIG_SYNC(TriggerOut),
	.oOUTPUT_CLK_RESET(CLK_custom_reset),

	.oARMED(Armed)
	,.oTEST(Test[3:0])
);

endmodule
